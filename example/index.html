<!DOCTYPE html>
<html lang="fr">

<head>
	<title>shriveling the world</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background: #000;
			color: #fff;
			padding: 0;
			margin: 0;
			font-weight: bold;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<script src="javascript/shriveling.js"></script>

	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();

		var container, stats, controls;

		var camera, scene, renderer;
		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;
		let board;
		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.bottom = '0px';
			stats.domElement.style.zIndex = 100;
			container.appendChild(stats.domElement);
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 15000);
			camera.position.set(0, 0, 500);

			scene = new THREE.Scene();
			scene.add(camera);
			camera.lookAt(scene.position);
			scene.fog = new THREE.Fog(0x000000, 1, 15000);

			var light = new THREE.PointLight(0xffffff);
			light.position.set(1000, 1000, 1000);
			scene.add(light);

			var ambient = new THREE.AmbientLight(0xffffff);
			scene.add(ambient);

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setClearColor(0x222222);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.sortObjects = false;
			container.appendChild(renderer.domElement);
			controls = new THREE.OrbitControls(camera, renderer.domElement);

			window.addEventListener('resize', onWindowResize, false);


			//skybox
			var urls = [
				'assets/px.jpg', 'assets/nx.jpg', 'assets/py.jpg', 'assets/ny.jpg', 'assets/pz.jpg', 'assets/nz.jpg',
			];

			var materialArray = [];
			var loader = new THREE.TextureLoader();
			for (var i = 0; i < 6; i++)
				materialArray.push(new THREE.MeshBasicMaterial({
					map: loader.load(urls[i]),
					side: THREE.BackSide
				}));

			var skyGeometry = new THREE.CubeGeometry(10000, 10000, 10000);
			var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
			var skybox = new THREE.Mesh(skyGeometry, skyMaterial);
			scene.add(skybox);

			shriveling.DragnDrop(container, (text, name) => {
				console.log(name);
				let start = new Date();
				if (board) {
					board.add(JSON.parse(text));
				} else {
					//			let projectionName='Equirectangular';
					let projectionName = 'none';
					//			let projectionName='Mercator';
					board = new shriveling.CountryBoard(JSON.parse(text), projectionName, scene, camera);
					board.show = false;
					let d2r = Math.PI / 180;
					let base = {
						2015: [{
							clock: 30 * d2r,
							elevation: 85 * d2r
						}, {
							clock: 210 * d2r,
							elevation: 30 * d2r
						}]
					}
					let positions = [
						new shriveling.Cartographic(175.882524, -39.675275, 0, false),
						new shriveling.Cartographic(46.826185, -19.309609, 0, false),
						new shriveling.Cartographic(132.207710, -24.028092, 0, false),
						new shriveling.Cartographic(105.063240, 61.854418, 0, false),
						new shriveling.Cartographic(0, 0, 0, false),
					]
					positions.forEach((summit, index) => {
						let name = 'index ' + index;
						let referential = new shriveling.NEDLocal(summit);
						let countryName = board.getCountryName(summit);
						let boundaryGeometries = board.getMeshes(countryName).map((mesh) => mesh.geometry);
						if (boundaryGeometries.length > 0) {
							let cone = new shriveling.ConeMesh(name, countryName, referential, base, boundaryGeometries, projectionName, Math.abs(shriveling.Configuration.extrudedHeight));
							scene.add(cone);
						}
					});
				}
				let stop = new Date();
				console.log((stop.getTime() - start.getTime()) / 1000);
			});
			container.addEventListener('dblclick', (evt) => {
				if (board) {
					let name = board.getMeshByMouse(evt, true);
					console.log(name);
				}
			});
		}

		function onWindowResize() {

			windowHalfX = window.innerWidth / 2;
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {

			requestAnimationFrame(animate);
			render();
			stats.update();
			controls.update();
			TWEEN.update();
		}

		function render() {
			renderer.render(scene, camera);
		}
	</script>

</body>

</html>
