<!doctype html>
<html lang="en">
<head>
	<title>A Shriveling world</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body bgcolor="#E6E6FA">

<script src="three.js"></script>
<script src="Papaparse.min.js"></script>
<script src="Detector.js"></script>
<script src="Stats.js"></script>
<script src="OrbitControls.js"></script>
<script src="THREEx.KeyboardState.js"></script>
<script src="THREEx.FullScreen.js"></script>
<script src="THREEx.WindowResize.js"></script>
<script src="bitview.js"></script>
<script src="shp.js"></script>
<script src="shp_three.js"></script>

<!-- ------------------------------------------------------------ -->

<div style="z-index: 2; position: absolute; left:5%; top:1%;width:90%;text-align: center;">
		<input id="rangeInput" type="range" value="31" max="40" min="0.5" step="0.1" style="width:100%;display:block">
		<span id="scaleText" style="color:white">1</span>
	</div>
	<div id="ThreeJS" style="z-index: 1; position: absolute; left:0px; top:0px"></div>
<script>
/*
	Three.js "tutorials by example"
	Author: Lee Stemkoski
	Date: July 2013 (three.js v59dev)
 */


//////////
// MAIN //
//////////

// standard global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var cube;

var earthRadius     = 6371;    // kilometres

var maxSpeedInitial = 300; //km/h
var maxSpeed        = 700; //km/h

var réduc = maxSpeedInitial/maxSpeed;

var roadSpeed     = 70;  //km/h
var motorwaySpeed = 100; //km/h
var HSTSpeed      = 250; //km/h

var slopeRoad     = 45; //in decimal degree
var slopeMotorway = 40; //in decimal degree
var slopeHST      = 30; //in decimal degree

var thresholdCities = 300; //in thousands of habitants

var coneRadius = 50;

var colorRed=0xff3333;
var colorWhite=0xffffff;
var colorBeige=0xF5F5DC;

console.log("Global reduction factor = "+réduc);
console.log("earthRadius*réduc = "+earthRadius*réduc);

function cones(wup) {
    //Data is usable here
    console.log(wup);
    var row=wup[3];
    for(var name in row){
        //console.log("nom de la colonne= ['"+name+"'] valeur = "+row[name]);
    }

	///////////
	// SCENE //
	///////////
	scene = new THREE.Scene();

	////////////
	// CAMERA //
	////////////

	// set the view size in pixels (custom or according to window size)
	// var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 300;
	var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
	// camera attributes
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	// set up camera
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	// add the camera to the scene
	scene.add(camera);
	// the camera defaults to position (0,0,0)
	// 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
    //camera.position.set(0,150,400);

	camera.position.set(3*earthRadius*réduc,-3*earthRadius*réduc,3*earthRadius*réduc);
	camera.lookAt(scene.position);

	//////////////
	// RENDERER //
	//////////////

	// create and start the renderer; choose antialias setting.
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer();

	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

	// attach div element to variable to contain the renderer
	container = document.getElementById( 'ThreeJS' );
	// alternatively: to create the div at runtime, use:
	//   container = document.createElement( 'div' );
	//    document.body.appendChild( container );

	// attach renderer to the container div
	container.appendChild( renderer.domElement );

	////////////
	// EVENTS //
	////////////

	// automatically resize renderer
	THREEx.WindowResize(renderer, camera);
	// toggle full-screen on given key press
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

	//////////////
	// CONTROLS //
	//////////////

	// move mouse and: left   click to rotate,
	//                 middle click to zoom,
	//                 right  click to pan
	controls = new THREE.OrbitControls( camera, renderer.domElement );

	///////////
	// STATS //
	///////////

	// displays current and past frames per second attained by scene
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );

	///////////
	// LIGHT //
	///////////

	// create a light
	var light = new THREE.PointLight(0xffffff);
	//light.position.set(0,250,0);
    light.position.set(3*earthRadius*réduc,-3*earthRadius*réduc,3*earthRadius*réduc);
	scene.add(light);
	var ambientLight = new THREE.AmbientLight(0x111111);
    scene.add(ambientLight);

	//////////////
	// GEOMETRY //
	//////////////

	// most objects displayed are a "mesh":
	//  a collection of points ("geometry") and
	//  a set of surface parameters ("material")


	var coneMaterial = new THREE.MeshPhongMaterial( { color: colorBeige });
    //var coneMaterial = new THREE.MeshNormalMaterial( { transparent: true, opacity: 0.5 } );
    var sphereMaterial = new THREE.MeshPhongMaterial( { color: colorRed });

	    var coneHeight = coneRadius * Math.sqrt((maxSpeed/roadSpeed)^2 -1);
    console.log(coneHeight);
    //                                      top radius, bottom radius, height
	var coneGeometry = new THREE.CylinderGeometry(0, coneRadius, coneHeight, 100, false);
	var sphereGeom = new THREE.SphereGeometry(5*réduc,32,32);
    var nbCities=0;
    for (var iter=1;iter<1693;iter++){
        if (wup[iter].pop2015 > thresholdCities) {
            nbCities++;

            var cone = new THREE.Mesh(coneGeometry, coneMaterial);
            var lat =   wup[iter].Latitude*Math.PI/180;
            var lon = - wup[iter].Longitude*Math.PI/180;
            var t =   wup[iter].Latitude*Math.PI/180;
            var a = - wup[iter].Longitude*Math.PI/180;
            /*cone.position.set (
                earthRadius * réduc * Math.cos(lat) * Math.cos(lon),
                earthRadius * réduc * Math.cos(lat) * Math.sin(lon),
                earthRadius * réduc * Math.sin(lat));*/
            cone.position.set (
                Math.cos(lon) * 90 * Math.cos(lat),
                Math.sin(lat) * 90,
                Math.sin(lon) * 90 * Math.cos(lat)
                );
            cone.lookAt( new THREE.Vector3(0,0,0) );
            cone.translateZ( - earthRadius * réduc);
            cone.translateZ( coneHeight/2);
            cone.rotateX(- Math.PI / 2 );
            //cone.translateY( - earthRadius * réduc);
            //cone.translateY( - coneHeight/2);
            scene.add(cone);

            var sphere = new THREE.Mesh(sphereGeom, sphereMaterial);
            /*sphere.position.set (
                earthRadius * réduc * Math.cos(lat) * Math.cos(lon)*90,
                earthRadius * réduc * Math.sin(lat)*90,
                earthRadius * réduc * Math.cos(lat) * Math.sin(lon)*90
                );*/
            sphere.position.set(
                Math.cos(lon) * 90 * Math.cos(lat),
                Math.sin(lat) * 90,
                Math.sin(lon) * 90 * Math.cos(lat)
            );
            sphere.lookAt( new THREE.Vector3(0,0,0) );
            sphere.translateZ( - earthRadius * réduc);
            scene.add(sphere);
        }

	}

    console.log("nbCities = "+nbCities);


	// create a set of coordinate axes to help orient user
	//    specify length in pixels in each direction
	var axes = new THREE.AxisHelper(100);
	scene.add( axes );


	/////////
	// SKY //
	/////////

	// recommend either a skybox or fog effect (can't use both at the same time)
	// without one of these, the scene's background color is determined by webpage background

	// make sure the camera's "far" value is large enough so that it will render the skyBox!
	var skyBoxGeometry = new THREE.CubeGeometry( 2*earthRadius, 2*earthRadius, 2*earthRadius );
	// BackSide: render faces from inside of the cube, instead of from outside (default).
	//var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: colorWhite, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
	scene.add(skyBox);

	// fog must be added to scene before first render
	//scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );

}

parseData("wup3.csv", cones);

var modelShapeFile,containShapefile, blueEarth;
SHPParser.load('110m_land.shp',
	function(res) {
		var parsedShp = res;
		var loader = new THREE.SHPLoader();
		modelShapeFile = loader.createModel(parsedShp, true);
		var compressed = loader.compress(parsedShp);
		containShapefile = loader.loadCompressed(compressed, true);
		blueEarth=new THREE.Mesh(
			new THREE.SphereGeometry(88,64, 64),
			new THREE.MeshBasicMaterial({color: 0x0000FF, opacity: 0.3, depthWrite:false})

            );
		//scene.add(blueEarth);
		//scene.add(modelShapeFile);
		scene.add(containShapefile);
    /*
        // The option: 'amount' is how far to extrude, 'bevelEnabled: false' prevents beveling
        var extrudedContinents = new THREE.ExtrudeGeometry(containShapefile, {amount: 50, bevelEnabled: false});

        // Geometry doesn't do much on its own, we need to create a Mesh from it
        var extrudedContinentsMesh = new THREE.Mesh(extrudedContinents, new THREE.MeshPhongMaterial({color: 0xff0000}));
        scene.add(extrudedContinentsMesh);*/

        //var continents = containShapefile.extrude({amount: 100, bevelThickness: 0.001, bevelSize: //0.001, bevelEnabled: false, curveSegments: 1});
        //scene.add(continents);
	});

var spanScale=document.getElementById('scaleText');
document.getElementById('rangeInput').addEventListener('input',function(evt){
var scale=evt.target.value;
	spanScale.innerHTML=scale;
	blueEarth.scale.set(scale, scale, scale);
	modelShapeFile.scale.set(scale, scale, scale);
	containShapefile.scale.set(scale, scale, scale);
    continents.scale.set(scale, scale, scale);
})



// animation loop / game loop
animate();


function parseData(url, callBack) {
    Papa.parse(url, {
	header: true,
	delimiter: ';',
	encoding: "utf-8",
	download: true,
	skipEmptyLines: false,
        dynamicTyping: true,

        complete: function(results) {
        	console.log(results.meta)
        	console.log(results.errors)
            callBack(results.data);

	    //$.each(results.data, function(i, el) {
		//var row = $("<tr/>");
		//row.append($("<td/>").text(i));
		//$.each(el, function(j, cell) {
		//        row.append($("<td/>").text(cell));
		//});
		//$("#results tbody").append(row);
	    //});
        }
    });
}



function animate()
{
    requestAnimationFrame( animate );
	render();
	update();
}

function update()
{
	// delta = change in time since last call (in seconds)
	var delta = clock.getDelta();

	// functionality provided by THREEx.KeyboardState.js
	if ( keyboard.pressed("1") )
		document.getElementById('message').innerHTML = ' Have a nice day! - 1';
	if ( keyboard.pressed("2") )
		document.getElementById('message').innerHTML = ' Have a nice day! - 2 ';

	controls.update();
	stats.update();
}

function render()
{
	renderer.render( scene, camera );
}

</script>

</body>
</html>

