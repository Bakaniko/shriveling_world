<!doctype html>
<html lang="en">
<head>
	<title>A Shriveling world</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body bgcolor="#E6E6FA">

<script src="three.js"></script>
<script src="Papaparse.min.js"></script>
<script src="Detector.js"></script>
<script src="Stats.js"></script>
<script src="OrbitControls.js"></script>
<script src="THREEx.KeyboardState.js"></script>
<script src="THREEx.FullScreen.js"></script>
<script src="THREEx.WindowResize.js"></script>
<script src="bitview.js"></script>
<script src="shp.js"></script>
<script src="shp_three.js"></script>

<!-- ------------------------------------------------------------ -->

<div style="z-index: 2; position: absolute; left:5%; top:1%;width:90%;text-align: center;">
		<input id="rangeInput" type="range" value="31" max="40" min="0.5" step="0.1" style="width:100%;display:block">
		<span id="scaleText" style="color:white">1</span>
	</div>
	<div id="ThreeJS" style="z-index: 1; position: absolute; left:0px; top:0px"></div>
<script>


//////////
// MAIN //
//////////

// standard global variables
var container, scene, camera, renderer, controls, stats, wup, tn;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var cube;

var earthRadius     = 6371;    // kilometres

var maxSpeedInitial = 300; //km/h
var maxSpeed        = 700; //km/h

var réduc = maxSpeedInitial/maxSpeed;

var roadSpeed     = 70;  //km/h
var motorwaySpeed = 100; //km/h
var HSTSpeed      = 250; //km/h

var slopeRoad     = 45; //in decimal degree
var slopeMotorway = 40; //in decimal degree
var slopeHST      = 30; //in decimal degree

var thresholdCities = 300; //in thousands of habitants

var coneRadius = 50;

var colorRed=0xff3333;
var colorWhite=0xffffff;
var colorBeige=0xF5F5DC;

console.log("Global reduction factor = ", Math.round(réduc*100)/100);
console.log("earthRadius*réduc = ", Math.round(earthRadius*réduc));

function cones(wup0) {
    //Data is usable here
    wup=wup0;
    //console.log(wup);
    var row=wup[3];
    for(var name in row){
        //console.log("nom de la colonne= ['"+name+"'] valeur = "+row[name]);
    }

	///////////
	// SCENE //
	///////////
	scene = new THREE.Scene();

	////////////
	// CAMERA //
	////////////

	// set the view size in pixels (custom or according to window size)
	// var SCREEN_WIDTH = 400, SCREEN_HEIGHT = 300;
	var SCREEN_WIDTH = window.innerWidth,
        SCREEN_HEIGHT = window.innerHeight;
	// camera attributes
	var VIEW_ANGLE = 45,
        ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,
        NEAR = 0.1,
        FAR = 20000;
	// set up camera
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	// add the camera to the scene
	scene.add(camera);
	// the camera defaults to position (0,0,0)
	// 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
    //camera.position.set(0,150,400);

	camera.position.set(3*earthRadius*réduc,-3*earthRadius*réduc,3*earthRadius*réduc);
	camera.lookAt(scene.position);

	//////////////
	// RENDERER //
	//////////////

	// create and start the renderer; choose antialias setting.
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer();

	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

	// attach div element to variable to contain the renderer
	container = document.getElementById( 'ThreeJS' );
	// alternatively: to create the div at runtime, use:
	//   container = document.createElement( 'div' );
	//    document.body.appendChild( container );

	// attach renderer to the container div
	container.appendChild( renderer.domElement );

	////////////
	// EVENTS //
	////////////

	// automatically resize renderer
	THREEx.WindowResize(renderer, camera);
	// toggle full-screen on given key press
	THREEx.FullScreen.bindKey({
        charCode : 'm'.charCodeAt(0)
    });


	// move mouse and: left   click to rotate,
	//                 middle click to zoom,
	//                 right  click to pan
	controls = new THREE.OrbitControls( camera, renderer.domElement );

	// displays current and past frames per second attained by scene
	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.bottom = '0px';
	stats.domElement.style.zIndex = 100;
	container.appendChild( stats.domElement );

	// create a light
	var light = new THREE.PointLight(0xffffff);
	//light.position.set(0,250,0);
    light.position.set(3*earthRadius*réduc,-3*earthRadius*réduc,3*earthRadius*réduc);
	scene.add(light);
	var ambientLight = new THREE.AmbientLight(0x111111);
    scene.add(ambientLight);

	//////////////
	// GEOMETRY //
	//////////////

	// most objects displayed are a "mesh":
	//  a collection of points ("geometry") and
	//  a set of surface parameters ("material")


	var coneMaterial = new THREE.MeshPhongMaterial( { color: colorBeige });
    //var coneMaterial = new THREE.MeshNormalMaterial( { transparent: true, opacity: 0.5 } );
    var sphereMaterial = new THREE.MeshPhongMaterial( { color: colorRed });

    var coneHeight = coneRadius * Math.sqrt((maxSpeed/roadSpeed)^2 -1); //this is the main geometric formula linkg speed and slope of cones

    console.log("coneRadius = ",coneRadius);
    console.log("coneHeight = ",coneHeight);
    //                                      top radius, bottom radius, height
	var coneGeometry = new THREE.CylinderGeometry(0, coneRadius, coneHeight, 100, false);
	var sphereGeom = new THREE.SphereGeometry(5*réduc,32,32);
    var nbCities=0;
    for (var iter=1;iter<wup.length;iter++){
        if (wup[iter].pop2015 > thresholdCities) {
            nbCities++;

            var cone = new THREE.Mesh(coneGeometry, coneMaterial);
            var φ =   wup[iter].Latitude*Math.PI/180;
            var λ = - wup[iter].Longitude*Math.PI/180;
                //φ phi lat     λ lambda lon

            cone.position.set (
                Math.cos(λ) * 90 * Math.cos(φ),
                Math.sin(φ) * 90,
                Math.sin(λ) * 90 * Math.cos(φ)
                );
            cone.lookAt( new THREE.Vector3(0,0,0) );
            cone.translateZ( - earthRadius * réduc);
            cone.translateZ( coneHeight/2);
            cone.rotateX(- Math.PI / 2 );
            scene.add(cone);

            var sphere = new THREE.Mesh(sphereGeom, sphereMaterial);
            sphere.position.set(
                Math.cos(λ) * 90 * Math.cos(φ),
                Math.sin(φ) * 90,
                Math.sin(λ) * 90 * Math.cos(φ)
            );
            sphere.lookAt( new THREE.Vector3(0,0,0) );
            sphere.translateZ( - earthRadius * réduc);
            scene.add(sphere);


        }

	}

    console.log("nbCities = "+nbCities);


    parent = new THREE.Object3D();
    parent.position.y = 50;
    scene.add( parent );

    function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {
        var points = shape.createPointsGeometry();
        var spacedPoints = shape.createSpacedPointsGeometry( 100 );
        // 3d shape
        var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
        var mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [ new THREE.MeshLambertMaterial( { color: color } ), new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } ) ] );
        mesh.position.set( x, y, z - 75 );
        mesh.rotation.set( rx, ry, rz );
        mesh.scale.set( s, s, s );
        parent.add( mesh );
    }

    var extrudeSettings = {	amount: 20,  bevelEnabled: true, bevelSegments: 2, steps: 2 }; // bevelSegments: 2, steps: 2 , bevelSegments: 5, bevelSize: 8, bevelThickness:5,

    // California

    var californiaPts = [];

    californiaPts.push( new THREE.Vector2 ( 610, 320 ) );
    californiaPts.push( new THREE.Vector2 ( 450, 300 ) );
    californiaPts.push( new THREE.Vector2 ( 392, 392 ) );
    californiaPts.push( new THREE.Vector2 ( 266, 438 ) );
    californiaPts.push( new THREE.Vector2 ( 190, 570 ) );
    californiaPts.push( new THREE.Vector2 ( 190, 600 ) );
    californiaPts.push( new THREE.Vector2 ( 160, 620 ) );
    californiaPts.push( new THREE.Vector2 ( 160, 650 ) );
    californiaPts.push( new THREE.Vector2 ( 180, 640 ) );
    californiaPts.push( new THREE.Vector2 ( 165, 680 ) );
    californiaPts.push( new THREE.Vector2 ( 150, 670 ) );
    californiaPts.push( new THREE.Vector2 (  90, 737 ) );
    californiaPts.push( new THREE.Vector2 (  80, 795 ) );
    californiaPts.push( new THREE.Vector2 (  50, 835 ) );
    californiaPts.push( new THREE.Vector2 (  64, 870 ) );
    californiaPts.push( new THREE.Vector2 (  60, 945 ) );
    californiaPts.push( new THREE.Vector2 ( 300, 945 ) );
    californiaPts.push( new THREE.Vector2 ( 300, 743 ) );
    californiaPts.push( new THREE.Vector2 ( 600, 473 ) );
    californiaPts.push( new THREE.Vector2 ( 626, 425 ) );
    californiaPts.push( new THREE.Vector2 ( 600, 370 ) );
    californiaPts.push( new THREE.Vector2 ( 610, 320 ) );

    var californiaShape = new THREE.Shape( californiaPts );



    //var extrudeSettings = { amount: 20 }; // bevelSegments: 2, steps: 2 , bevelSegments: 5, bevelSize: 8, bevelThickness:5
    var extrudeSettings = { amount: 200, bevelSegments: 2, steps: 2 , bevelSegments: 5, bevelSize: 8, bevelThickness:5};
    // addShape( shape, color, x, y, z, rx, ry,rz, s );
    addShape( californiaShape, extrudeSettings, 0xffaa00, -300, -100, 0, 0, 0, 0, 3 );


	// create a set of coordinate axes to help orient user
	//    specify length in pixels in each direction
	var axes = new THREE.AxisHelper(100);
	scene.add( axes );


	/////////
	// SKY //
	/////////

	// recommend either a skybox or fog effect (can't use both at the same time)
	// without one of these, the scene's background color is determined by webpage background

	// make sure the camera's "far" value is large enough so that it will render the skyBox!
	var skyBoxGeometry = new THREE.CubeGeometry( 2*earthRadius, 2*earthRadius, 2*earthRadius );
	// BackSide: render faces from inside of the cube, instead of from outside (default).
	//var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
	var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: colorWhite, side: THREE.BackSide } );
	var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
	scene.add(skyBox);

	// fog must be added to scene before first render
	//scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );

}

function transportNetwork(){

    //console.log("tn ",tn);
    //console.log("wup ",wup);
    //var ori = THREE.Vector3();
    //var des = THREE.Vector3();
    var wupOri, wupDes, φOri, λOri, φDes, λDes;

    for (var iter=1;iter<tn.length;iter++){
        var iOri = wup.map(obj => obj.CityCode).indexOf(tn[iter].idOri);
        if (iOri != -1) {
            //console.log( "  tn[iter].nameOri ", tn[iter].nameOri);
            //console.log( "  wup[iOri].UrbanAgglomeration ",  wup[iOri].UrbanAgglomeration);
            //console.log("wup ",wup);
            //console.log("iOri ",iOri);
            //console.log(" wup[iOri].Latitude ", wup[iOri].Latitude);
            tn[iter].oriLatitude  = wup[iOri].Latitude;
            tn[iter].oriLongitude = wup[iOri].Longitude;
            φOri =   wup[iOri].Latitude*Math.PI/180;
            λOri = - wup[iOri].Longitude*Math.PI/180;
            var vecOri = new THREE.Vector3(
                Math.cos(λOri) * 90 * Math.cos(φOri),
                Math.sin(φOri) * 90,
                Math.sin(λOri) * 90 * Math.cos(φOri)
            );
           // ori.translateZ( - earthRadius * réduc);
            vecOri.z += - earthRadius * réduc;
            //console.log("vecOri ",vecOri);
            var iDes = wup.map(obj => obj.CityCode).indexOf(tn[iter].idDes);
            if (iDes != -1) {
                tn[iter].desLatitude  = wup[iDes].Latitude;
                tn[iter].desLongitude = wup[iDes].Longitude;
                φDes =   wup[iDes].Latitude*Math.PI/180;
                λDes = - wup[iDes].Longitude*Math.PI/180;
                var vecDes = new THREE.Vector3(
                    Math.cos(λDes) * 90 * Math.cos(φDes),
                    Math.sin(φDes) * 90,
                    Math.sin(λDes) * 90 * Math.cos(φDes)
                    );
                //des.translateZ( - earthRadius * réduc);*/
                vecDes.z += - earthRadius * réduc;

                //var cp = createCurvePath(ori, des, 200);
                //var middle = (new LatLon(wup[iOri].latitude,wup[iOri].longitude)).midpointTo(new LatLon(wup[iDes].latitude, wup[iDes].longitude));
                //φ phi lat     λ lambda lon
                //var Bx = Math.cos(φ2) * Math.cos(λ2-λ1);
                var Bx = Math.cos(φDes) * Math.cos(λDes-λOri);
                var Bx = Math.cos(φDes) * Math.cos(λDes-λOri);
                var By = Math.cos(φDes) * Math.sin(λDes-λOri);
                var φMid = Math.atan2(Math.sin(φOri) + Math.sin(φDes),
                                Math.sqrt( (Math.cos(φOri)+Bx)*(Math.cos(φOri)+Bx) + By*By ) );
                var λMid = φOri + Math.atan2(By, Math.cos(φOri) + Bx);
                var vecMid = new THREE.Vector3(
                    Math.cos(λMid) * 90 * Math.cos(φMid),
                    Math.sin(λMid) * 90,
                    Math.sin(φMid) * 90 * Math.cos(φMid) - earthRadius * réduc
                    );
                vecMid.setZ(- earthRadius * réduc);
                console.log("vecOri ",vecOri);
                console.log("vecMid ",vecMid);
                console.log("vecDes ",vecDes);

                var geomBezier = new THREE.QuadraticBezierCurve3(vecOri, vecMid, vecDes);
                var cp = new THREE.Geometry();
                cp.vertices.push(vecOri);
                cp.vertices.push(vecMid);
                cp.vertices.push(vecDes);
                var curvedLineMaterial =  new THREE.LineBasicMaterial({
                    color: colorRed, // 0xFFFFAA,
                    linewidth: 300
                });
                var curvedLine = new THREE.Line(cp, curvedLineMaterial);
                scene.add(curvedLine);
            }
        }


    }
}



var promiseWup=parseData("wup3.csv",cones);// génération de la promesse de wup

var promiseTn=parseData("transport_network.csv",
                        function(tn0){
                            tn=tn0;
                        }); //génération de la promesse de tn

Promise.all([promiseWup,promiseTn]).then(function() {
    transportNetwork();
});




var modelShapeFile,containShapefile, blueEarth;
SHPParser.load('110m_land_shrivel.shp',
	function(res) {
		var parsedShp = res;
		var loader = new THREE.SHPLoader();
		modelShapeFile = loader.createModel(parsedShp, true);
		var compressed = loader.compress(parsedShp);
		containShapefile = loader.loadCompressed(compressed, true);
		blueEarth=new THREE.Mesh(
			new THREE.SphereGeometry(88,64, 64),
			new THREE.MeshBasicMaterial({color: 0x0000FF, opacity: 0.3, depthWrite:false})

            );
		//scene.add(blueEarth);
		//scene.add(modelShapeFile);
		scene.add(containShapefile);
    /*
        // The option: 'amount' is how far to extrude, 'bevelEnabled: false' prevents beveling
        var extrudedContinents = new THREE.ExtrudeGeometry(containShapefile, {amount: 50, bevelEnabled: false});

        // Geometry doesn't do much on its own, we need to create a Mesh from it
        var extrudedContinentsMesh = new THREE.Mesh(extrudedContinents, new THREE.MeshPhongMaterial({color: 0xff0000}));
        scene.add(extrudedContinentsMesh);*/

        //var continents = containShapefile.extrude({amount: 100, bevelThickness: 0.001, bevelSize: //0.001, bevelEnabled: false, curveSegments: 1});
        //scene.add(continents);
	});

var spanScale=document.getElementById('scaleText');
document.getElementById('rangeInput').addEventListener('input',function(evt){
var scale=evt.target.value;
	spanScale.innerHTML=scale;
    scale=scale*10;
	blueEarth.scale.set(scale, scale, scale);
	modelShapeFile.scale.set(scale, scale, scale);
	containShapefile.scale.set(scale, scale, scale);
    //continents.scale.set(scale, scale, scale);
})



var createCurvePath = function(start, end, elevation) {
        var start3 = globe.translateCordsToPoint(start.latitude,start.longitude);
        var end3 = globe.translateCordsToPoint(end.latitude, end.longitude);
        var mid = (new LatLon(start.latitude,start.longitude)).midpointTo(new LatLon(end.latitude, end.longitude));
       var middle3 = globe.translateCordsToPoint(mid.lat(), mid.lon(), elevation);

        var curveQuad = new THREE.QuadraticBezierCurve3(start3, middle3, end3);
   //   var curveCubic = new THREE.CubicBezierCurve3(start3, start3_control, end3_control, end3);

        var cp = new THREE.CurvePath();
        cp.add(curveQuad);
   //   cp.add(curveCubic);
        return cp;
    }




// animation loop
animate();


function parseData(url, callBack) {
    return new Promise(function(resolve, reject) {
        Papa.parse(url, {
            header: true,
            delimiter: ';',
            encoding: "utf-8",
            download: true,
            skipEmptyLines: false,
            dynamicTyping: true,

            complete: function(results) {
                //console.log(results.meta)
                console.log(results.errors)
                callBack(results.data);
                resolve(results.data);

                //$.each(results.data, function(i, el) {
                //var row = $("<tr/>");
                //row.append($("<td/>").text(i));
                //$.each(el, function(j, cell) {
                //        row.append($("<td/>").text(cell));
                //});
                //$("#results tbody").append(row);
                //});
            },
            error: function(err) {
                reject(err);
            }
        });
    });
}



function animate()
{
    requestAnimationFrame( animate );
	render();
	update();
}

function update()
{
	// delta = change in time since last call (in seconds)
	var delta = clock.getDelta();

	// functionality provided by THREEx.KeyboardState.js
	if ( keyboard.pressed("1") )
		document.getElementById('message').innerHTML = ' Have a nice day! - 1';
	if ( keyboard.pressed("2") )
		document.getElementById('message').innerHTML = ' Have a nice day! - 2 ';

	controls.update();
	stats.update();
}

function render()
{
	renderer.render( scene, camera );
}

</script>

</body>
</html>

